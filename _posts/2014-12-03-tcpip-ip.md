---
layout: post
title:  "tcp/ip协议学习 第三章 IP协议"
date:   2014-12-03 23:39:41 +0800
modifydate: 2014-12-05 17:21:54 +0800
abstract:   "1. 路由表 <br>
2. 代码实现发送raw IP包"
categories: net
---

[关于IP的RFC文档在此!](https://tools.ietf.org/html/rfc791)

IP的头文件还是先贴一下, 总是记不住.

```
   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

# 网络和子网划分
不太明白ABCD四类地址划分的意义,除了在路由选择的匹配中会配合子网划分用到.


# 路由表, 路由选择
以前本科的时候, IP配置好之后, 学校内网是可以访问的.  如果想访问外网, 需要拨号.但拨号之后内网就不方便上了.

学校网站有个小程序, 可以傻瓜式的修改系统路由. 拨号之后内网外网一起上.

当时不明白这是个什么东西, 其实现在也想不太明白怎么回事, 也没条件回学校试验下了. 但至少现在也算大概明白路由表以及路由选择了.

之前为了学习, 拿公司的网络实验了一把.  [osx下面的双网卡路由配置](/2014/12/02/route-table-config.html)


# 来段程序吧
## python
用程序发送raw IP包的时候, Total Length 和 Checksum 会由内核自动生成. 至于为啥,可能看到tcpip协议详解下(实现)的时候就知道了吧.

Checksum 算法在模拟后面协议的时候就要自己实现了.ICMP、IGMP、UDP和TCP都采用相同的检验和算法. 

有个不同点是: 首部检验和字段是根据IP头计算的检验和码。它不对body进行计算。 ICMP、 IGMP、UDP和TCP的checksum覆盖首部和数据。

```py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''发送一个裸的IP包, 20字节的IP头, 后面跟一个随便写的字符串.
还不知道IP包的ID应该根据什么生成, 就随便写了一个54321
IP头里面:
    IP包总长度属性和checksum属性都是内核自动生成的.
    协议是用的socket.IPPROTO_TCP,也就是6.但没什么用,IP包里面就随便的字符串,不是按TCP协议来的.
'''

import socket
from struct import pack
import sys


def main():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
    except socket.error as msg:
        print 'Socket could not be created. Error Code : ' + str(msg[0]) + ' Message ' + msg[1]
        return

    packet = ''

    source_ip = '127.0.0.1'
    dest_ip = '127.0.0.1'

    # ip header fields
    ip_ver = 4
    ip_ihl = 5
    ip_tos = 0
    ip_tot_len = 0  # kernel will fill the correct total length
    ip_id = 54321
    ip_frag_off = 0
    ip_ttl = 32
    ip_proto = socket.IPPROTO_TCP  # no use in this case
    ip_checksum = 0    # kernel will fill the correct checksum

    ip_saddr = socket.inet_aton(source_ip)
    ip_daddr = socket.inet_aton(dest_ip)

    ip_ihl_ver = (ip_ver << 4) + ip_ihl

    # the ! in the pack format string means network order
    ip_header = pack(
        '!BBHHHBBH4s4s',
        ip_ihl_ver,
        ip_tos,
        ip_tot_len,
        ip_id,
        ip_frag_off,
        ip_ttl,
        ip_proto,
        ip_checksum,
        ip_saddr,
        ip_daddr)

    user_data = sys.argv[1] if sys.argv[1:] else '0123456789'

    packet = ip_header + user_data

    # the port specified has no effect
    r = s.sendto(packet, (dest_ip, 0))

    # result is the length of packet sent out
    print r

if __name__ == '__main__':
    main()
    ip_check = 1231    # kernel will fill the correct checksum
```
