---

title: 算法导论 笔记3 5.1-雇佣问题
date: 2018-11-10T15:56:40+0800
layout: post

---

## 5.1-1

我是看的中文版本, 我觉得这个翻译的不对, 应该是说满足`全序关系`.  首先要理解什么是`全序关系的集合`, 这是一个严格的数学定义. 参考[https://zh.wikipedia.org/wiki/全序关系](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BA%8F%E5%85%B3%E7%B3%BB)

	全序关系即集合 {\displaystyle X} X上的反对称的、传递的和完全的二元关系

还有一点就是, '总能决定哪一个应聘者最佳', 不是说'运行一次这个代码, 第四行的代码都可以决定哪个最佳' , 而是说不管如何随机, 如果打乱应聘者顺序, 运行多次, 乃至无数次, 第四行的代码都可以决定哪个最佳. 如果不这么理解, 全序关系就正明不了. 

但我不知道怎么算是严格的数学意义上的证明, 简单说一下吧.

反对称性, 若 a>=b && b>=a, 则 a==b . 关于反对称性, 我觉得, 还有另外一个翻译不准确的地方, '总能决定哪一个应聘者最佳', 是说两两比较总能区分哪一个更好, 不能出现一样好的情况. 如果单看代码的话, 是有可能出现 a == b 的. 如果所有应聘者都是能力相同, 那么反对称性就满足不了了. 按自我纠正后的理解呢, 可以用反证法证明: 如果不满足反对称, 则A和B就不是'总能区分哪一个更好', 所以一定满足反对称性.

传递性, 这个真不知道怎么算'证明', A比B好, B比C好, A'明显'比C好, 这个需要证明吗?

完全性, a<=b, 或者 b<=a . 既然'总能区分哪一个更好', 说明a和b总有一个比另外一个好. 用反证更好理解: 如果不满足完全性, 就是说a和b不能比较哪个更好, 这样就不能保证'总能区分哪一个更好', 所以一定要满足完全性.

## 5.1-2

这个问题我想了好几天,  终于没想出来一个'可靠'的好办法, 后面网上搜索了别人的回答, 和我的一样'不算可靠', 看来只能这样了.

先说下我的思路.

1. 如果已有 rand(1, n), 返回 1-n 之间随机一个数字. 这里的n是所有2的整数次方, 2, 4, 8, 16 ... 1024 ...
2. 求 rand(1, x), 只需要按下面这样, 找一个比x大的n
		r = rand(1, n)
		while r > x:
			r = rand(1, n)
		return r
3. 现在的问题就是假设1 能不能实现, 怎么实现. 这个很简单. `rand(1, 2*n) = rand(1, n) * rand(1, 2)`

网上看到的回答, 基本原理是一样的, 但合在一步里面了, 并不需要先求 rand(1, n)

对于 rand(1, x), 先找一个最小的n,使 pow(2,n) >= x, 比如求 rand(1,5), 则取 n=3 , 然后

```
r = x + 1
while r > n {
	r = 0
	for i = 1; i <= n; i++ {
		r = 2*r + rand(0,1)
	}
}
return n
```

我说他'不可靠', 是因为这个 `while r > x` 的条件可能永远达成不了, 最坏时间复杂度应该是无限大吧, 但还是可以计算一下平均时间复杂度. 我算下来, 平均时间复杂度是 O(n), 这里的n不是x, 就是上面描述里面的n.

计算方式如下:

首先呢, 如果x正好是2的某整数次方, 那么不会死循环, 一次过. 坏情况是x正好是2的某整数次方+1, 这种情况下, 一次过的概率只有1/2, 还有1/2的概率需要重新再来一次.

设期望运行时间, 也就是运行 `r = 2*r + rand(0,1)` 这行代码的次数的期望吧, 为 f(n), 那么 f(n) = 1/2 * n + 1/2 * f(n) , 求得 f(n) = n

来验证一下吧, 写了个python代码如下.

```
# -*- coding: utf-8 -*-

import random
import time
import sys
import math

def f(x, n):
    r = x + 1
    while r >= x:
        r = 0
        for _ in range(n):
            r = 2*r + random.randint(0, 1)
    return r

if __name__ == '__main__':
    x = int(eval(sys.argv[1]))
    n = int(math.ceil(math.log(x, 2)))
    print x,n

    s = time.time()
    for _ in range(10000):
        f(x, n)
    print time.time() - s
```

运行结果

```
% python a.py "2**9+1"
513 10
0.43741607666

% python a.py "2**19+1"
524289 20
0.82234287262
```
