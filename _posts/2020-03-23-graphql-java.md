---

layout: post
date: 2020-03-23T17:12:35+0800

---

## 写在最前

我不是写一个 GraphQL 的使用指南, 是在写自己对 GraphQL 的一些使用感受. 我自己是非常喜欢它, 愿意给他打10分, 虽然还有些小瑕疵. 如果你用过 GraphQL 了, 可以看看我们是不是有同感.

另外多提两句. 1 GraphQL 本身是一个协议, 每种语言都有自己的框架实现, 我自己只用过 Java 的.  2 他是一个执行引擎, 不是 HTTP 框架, 你可以在任何地方使用他们, 当然现在最常见的是提供 HTTP 接口.

## 当前开发模式(未使用 GraphQL 前)

先说 API 协议设计上面.

请求(Request): Client 给需要的一些参数. 拿`取文章列表`这个接口举例: 请求中给`分页大小` `当前是第几页` `排序方法(热度/发布时间/打分等)`.
响应(Response): 就是按需要给 Client 返回他需要的字段.

然后简单说一下代码实现上面.

从数据库,或者是别的服务接口取回需要的数据, 然后按一定的逻辑做一些过滤, 做一些字段的组装, 返回给调用者.


### 痛点

1. 难以做到按需提供 API. 这是 GraphQL 着重宣传的点, 但我的觉得后面两点才是 GraphQL 更爽的地方.

    想像一样, 我们给客户 A 提供了一个文章列表的 API. 后面客户 B 说我们需要作者的级别. 我们就在 API Response 里面再添加一个字段. 后面客户 C 又说我们需要另外一个字段, 字段可能会越加越多.

    取有些字段可能还会比较费时, 那么给 C 加的字段导致 A 调用时长增加了. 这时候, 我们可能会在 Request 里面增加一个参数, 可以默认不返回某字段, 只有 C 调用的时候才返回这个字段.

    又或者说, 用户 A 需要对每篇文章返回10条评论, C 需要20条. 又需要增加一个参数(这些参数基本上都是最外层的, 没有规范的命名标准).

    但总的来说, 没有一套规范, 这点和 GraphQL 有鲜明的对比. GraphQL 里面可以对每一个返回的字段都做到字段级别的传参.

2. Do Dto Ao Vo 等各层对象转来转去. 增加一个字段, 可能会在每个转换的地方都要修改代码, 非常繁琐.

3. 飞线代码多, 逻辑分散在各个地方, 特别是多人开发, 项目多次转交后.

    就我自己的实际经验, 来举个例子, 一个新接手的项目. 文章作者下面有标签字段, 包含标签类型和标签名字. 新需求想把一个接口A 里面的作者标签做些过滤, 某种类型的标签就不要返回了.

    AuthorService 生成 Author 以及标签的函数, 被多个其他函数引用, 这些函数又被引用, 最后被多个接口使用. 那对我来说, 完成需求的最简单的方法, 就是在接口 A 最后返回的时候, 把标签过滤一下. 我把这段代码叫做飞线代码. 时间长了, 这种情况多了, 飞线越来越多, 字段的值可能会在多个地方, 在不同的逻辑下被修改. 给 Debug 和代码可读性带来痛苦.

## GraphQL 优势

### 减少 dto - ao- vo 转换

### 代码复用

    虽然这里是写了"代码复用", 但我觉得比代码复用更简单, 更清楚, 写起来更简单, 别人看起来也一目了然.

    这个是因为 GraphqL 的框架本身的优势, 这里特指 Java 的, 别的语言的我没有用过.

### 逻辑清晰

### 更自然的并行

### 规范化的批量处理

## 一些实践经验

### 平级和跨级依赖

### 尽量使用 DataLoader

### dataLoader 注册名字规范

### async

### enum

### 手动 Dispatch

### 设计好schema!

## GraphQL-Java 框架的不足

### 依赖
